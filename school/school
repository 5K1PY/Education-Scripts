#!/usr/bin/env python

import argparse
import os
from functools import partial

from signal import signal, SIGINT

from course import Courses
from homework import Homeworks
from utilities import *

# catch SIGINT and prevent it from terminating the script, since an instance of Ranger
# might be running and it crashes when called using subprocess.Popen (might be related
# to https://github.com/ranger/ranger/issues/898)
signal(SIGINT, lambda _, __: None)


### GLOBAL VARIABLES ###
# change path to current folder for the script to work
# remember it, though, since we might need it
cwd = os.getcwd()
os.chdir(os.path.dirname(os.path.realpath(__file__)))


### ARGUMENTS ###
parser = argparse.ArgumentParser(
    description="A script for simplifying my university education.",
    formatter_class=argparse.RawTextHelpFormatter,
)

parser.add_argument(
    "actions",
    nargs="+",
    help=(
        "list\n"
        "├── courses <when>\n"
        "├── finals\n"
        "└── timeline\n"
        "cron\n"
        "open\n"
        "├── course <course name/abbreviation>\n"
        "├── website <course name/abbreviation>\n"
        "└── notes <course name/abbreviation>\n"
        "initialize\n"
        "homework\n"
        "├── list <course name/abbreviation>\n"
        "├── add <course name/abbreviation>\n"
        "├── edit <homework UID>\n"
        "├── delete <homework UID>\n"
        "└── complete <homework UID>\n"
    ),
)

parser.add_argument("-s", "--short", action="store_true", help="shorten the output")
parser.add_argument("-f", "--folder", help="set the courses folder (overrides config file)")


arguments = parser.parse_args()

courses = Courses(arguments.folder or courses_folder)
homeworks = Homeworks(courses)

action_tree = {
    "homework": {
        "list": homeworks.list,
        "add": homeworks.add,
        "edit": homeworks.edit,
        "delete": homeworks.delete,
        "complete": homeworks.complete,
    },
    "list": {
        "courses": courses.list,
        "finals": courses.finals,
        "timeline": courses.timeline,
    },
    "cron": courses.compile_cron_jobs,
    "open": {
        "course": partial(courses.open, "folder"),
        "website": partial(courses.open, "website"),
        "notes": partial(courses.open, "notes"),
        "online": partial(courses.open, "online"),
    },
    "initialize": partial(courses.initialize, cwd),
}


# go down the action tree
while len(arguments.actions) != 0 and type(action_tree) is dict:
    action = arguments.actions.pop(0)

    # sort the actions by their common prefix with the argument
    actions = sorted(
        ([(1, a) if a.startswith(action) else (0, a) for a in action_tree])
    )

    # if no match is found, quit with error
    if actions[-1][0] == 0:
        exit_with_error(
            f"'{action}' doesn't match actions in the action tree:"
            f" {{{', '.join(action_tree)}}}."
        )

    # filter out the sub-optimal actions (i. e. those
    while actions[0][0] != actions[-1][0]:
        actions.pop(0)

    # if there are multiple optimal solutions, the command is ambiguous
    if len(actions) > 1:
        exit_with_error(
            f"Ambiguous actions for '{action}':"
            f" {{{', '.join([a for _, a in actions])}}}"
        )

    # else follow the best solution
    else:
        action_tree = action_tree[actions[0][1]]

# if the action tree isn't a function by now, exit; else extract the function
if type(action_tree) is dict:
    exit_with_error(f"Actions remaining: {{{', '.join(action_tree)}}}")

try:
    action_tree(*arguments.actions, **vars(arguments))
except TypeError as e:
    exit_with_error("Invalid arguments for the specified action.")
