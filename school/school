#!/usr/bin/env python

import sys
import os
from subprocess import call
from typing import *
from functools import partial
import argparse

from config import *
from private_config import *

from course import Course, Courses
from homework import Homework, Homeworks
from utilities import *


# catch SIGINT and prevent it from terminating the script, since an instance of Ranger
# might be running and it crashes when called using subprocess.Popen (might be related
# to https://github.com/ranger/ranger/issues/898)
from signal import signal, SIGINT

signal(SIGINT, lambda _, __: None)


### GLOBAL VARIABLES ###
# change path to current folder for the script to work
# remember it, though, since we might need it
cwd = os.getcwd()
os.chdir(os.path.dirname(os.path.realpath(__file__)))


### ARGUMENTS ###
parser = argparse.ArgumentParser(
    description="A script for simplifying my university education.",
)

parser.add_argument(
    "actions",
    nargs="+",
    help="the actions for the script to make; see README for details",
)

parser.add_argument(
    "-s", "--short", dest="short", action="store_true", help="shorten the output",
)

arguments = parser.parse_args()


action_tree = {
    "homework": {
        "list": Homeworks.list,
        "add": Homeworks.add,
        "edit": Homeworks.edit,
        "delete": Homeworks.delete,
        "complete": Homeworks.complete
    },
    "list": {
        "courses": Courses.list,
        "finals": Courses.finals,
        "timeline": Courses.timeline,
    },
    "cron": Courses.compile_cron_jobs,
    "send": partial(Courses.send_mail, cwd),
    "open": {
        "course": partial(Courses.open, "folder"),
        "website": partial(Courses.open, "website"),
        "notes": partial(Courses.open, "notes"),
    },
    "initialize": partial(Courses.initialize, cwd),
}


# go down the action tree
while len(arguments.actions) != 0 and type(action_tree) is dict:
    action = arguments.actions.pop(0)

    # sort the actions by their common prefix with the argument
    actions = sorted(
        ([(1, a) if a.startswith(action) else (0, a) for a in action_tree])
    )

    # if no match is found, quit with error
    if actions[-1][0] == 0:
        exit_with_error(
            f"'{action}' doesn't match actions in the action tree: {{{', '.join(action_tree)}}}."
        )

    # filter out the sub-optimal actions (i. e. those
    while actions[0][0] != actions[-1][0]:
        actions.pop(0)

    # if there are multiple optimal solutions, the command is ambiguous
    if len(actions) > 1:
        exit_with_error(
            f"Ambiguous actions for '{action}': {{{', '.join([a for _, a in actions])}}}"
        )

    # else follow the best solution
    else:
        action_tree = action_tree[actions[0][1]]

# if the action tree isn't a function by now, exit; else extract the function
if type(action_tree) is dict:
    exit_with_error(f"Actions remaining: {{{', '.join(action_tree)}}}")

try:
    action_tree(*arguments.actions, **vars(arguments))
except TypeError as e:
    print(e)
    exit_with_error("Invalid arguments for the specified action.")
