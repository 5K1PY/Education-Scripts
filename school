#!/usr/bin/env python

import sys
import os
from subprocess import call, Popen, PIPE
from datetime import timedelta, datetime, date
from typing import *
from functools import partial
from unidecode import unidecode

# configuration
from config import *
from private_config import *

from course import Course
from util import *

import md_to_pdf.md_to_pdf


# catch SIGINT and prevent it from terminating the script, since an instance of Ranger
# might be running and it crashes when called using subprocess.Popen (might be related
# to https://github.com/ranger/ranger/issues/898)
from signal import signal, SIGINT

signal(SIGINT, lambda _, __: None)


### GLOBAL VARIABLES ###
# change path to current folder for the script to work
# remember it, though, since we might need it
cwd = os.getcwd()
os.chdir(os.path.dirname(os.path.realpath(__file__)))

# flags
short = False

help_offset = 20


def get_ongoing_course() -> Union[Course, None]:
    """Returns the currently ongoing course (or None if there is no ongoing course)."""
    for course in get_sorted_courses(include_unscheduled=False):
        if course.is_ongoing():
            return course


def get_course_from_argument(argument: str) -> List[Course]:
    """Returns all courses that match the format name-[type] or abbreviation-[type].
    Examples: of valid identifiers (1st semester): ups-c, la, la-p, dm-c."""
    # special case for no argument at all
    if argument is None:
        ongoing = get_ongoing_course()
        return [ongoing] if ongoing is not None else get_course_from_argument("next")

    # special case for 'next'
    if argument in ("n", "next"):
        today = datetime.today()

        MID = 1440  # minutes in a day
        MIW = 10080  # minutes in a week

        current_week_time = today.weekday() * MID + today.hour * 60 + today.minute
        min_time, min_course = float("+inf"), None

        # TODO: do binary search
        for course in get_sorted_courses(include_unscheduled=False):
            time_to_course = (
                (course.time.start + course.weekday() * MID) - current_week_time
            ) % MIW

            if time_to_course < min_time:
                min_time = time_to_course
                min_course = course

        return [min_course]

    # if the argument is not 'next', try to interpret the identifier as an abbreviation
    if "-" not in argument:
        abbr = argument.lower()
        type = None
    else:
        abbr, type = argument.lower().split("-", 1)

    # courses that were parsed as if the argument was an abbreviation
    abbr_courses = [
        course
        for course in get_sorted_courses()
        if abbr == course.abbreviation.lower() and type in {None, course.type[0]}
    ]

    # return the courses for argument as an abbreviation or for argument as a name
    return (
        abbr_courses
        if len(abbr_courses) != 0
        else [
            course
            for course in get_sorted_courses()
            if unidecode(course.name.lower()).startswith(unidecode(abbr.lower()))
            and type in {None, course.type[0]}
        ]
    )


def get_next_course_message(i: int, courses: list) -> str:
    """Returns the string of the cron job that should be ran for the upcoming course."""
    course = (
        None
        if i + 1 >= len(courses) or courses[i].time.day != courses[i + 1].time.day
        else courses[i + 1]
    )

    return (
        "Dnes již žádný další předmět není."
        if course is None
        else (
            f"Další předmět je <i>{course.name} ({course.type})</i>, "
            f"který začíná <i>{course.time.start - courses[i].time.end} minut</i> po tomto"
            + (
                "."
                if course.classroom is None
                else (
                    f" v učebně <i>{course.classroom.number}</i>"
                    + (
                        "."
                        if course.classroom.floor is None
                        else (f" ({course.classroom.floor}. patro).")
                    )
                )
            )
        )
    )


def get_sorted_courses(include_unscheduled=False) -> List[Course]:
    """Returns a list of Course dataclasses from the courses .yaml files. This method
    ignores courses without a schedule by default."""
    courses = []

    # find all .yaml files in the school path
    for root, _, filenames in os.walk(courses_folder):
        for filename in filter(lambda f: f.endswith(".yaml"), filenames):
            # initialize a course from the path
            course = Course.from_file(os.path.join(root, filename))

            # either it's a normal or an unscheduled course
            if course.time is not None or include_unscheduled:
                courses.append(course)

    # sort by time
    return sorted(
        courses, key=lambda c: (0, 0) if not c.time else (c.weekday(), c.time.start)
    )


def list_finals():
    """Lists dates of all finals."""
    # get courses that have finals records in them
    finals_courses = [c for c in get_sorted_courses() if c.finals is not None]
    if len(finals_courses) == 0:
        sys.exit("No finals added!")

    # build a table
    finals = [["Finals!"]]

    for course in sorted(finals_courses, key=lambda c: c.finals.date):
        final = course.finals

        delta = final.date.replace(tzinfo=None) - datetime.today()
        due_msg = "done" if delta.days < 0 else f"{delta.days + 1} days"

        finals.append(
            [
                course.name,
                final.date.strftime("%_d. %-m. %Y"),
                final.date.strftime("%_H:%M"),
                due_msg,
                str(final.classroom.number),
                "-" if final.classroom.floor is None else str(final.classroom.floor),
            ]
        )

    print_table(finals)


def list_timeline():
    """List the courses in a timeline."""
    beginning_minutes = int(7.34 * 60)  # starting time is 7:20
    end_minutes = int(21 * 60)

    interval = 100  # 100 minutes for each period (90 + 10)

    total_minutes = ((end_minutes - beginning_minutes) // interval + 1) * interval
    number_of_intervals = total_minutes // interval

    # separate courses based on weekdays
    days = [[] for _ in range(5)]
    for course in get_sorted_courses(include_unscheduled=False):
        days[course.weekday()].append(course)

    # print the header
    print(
        ("╭" + "─" * (total_minutes // 10) + "╮\n│")
        + "".join(
            minutes_to_HHMM(beginning_minutes + interval * i).strip().ljust(10, " ")
            for i in range(number_of_intervals)
        )
        + "│\n├─"
        + "".join(
            "─" * (number_of_intervals) + ("┬" if i != number_of_intervals - 1 else "┤")
            for i in range(number_of_intervals)
        )
    )

    # a buffer for adding course line strings
    print_buffer = ["" for _ in range(len(days))]
    for i, day in enumerate(days):
        print_buffer[i] += "│"

        for j, course in enumerate(day):
            prev_course = days[i][j - 1]

            # duration before course start
            if j == 0:
                wait = (course.time.start - beginning_minutes) // 10
            else:
                wait = (course.time.start - prev_course.time.end) // 10

            duration = (course.time.end - course.time.start) // 10

            # python's .center aligns right and it looks ugly
            name = (course.abbreviation + "-" + course.type[0]).upper()
            if len(name) % 2 == 0:
                name += " "

            print_buffer[i] += " " * wait + "{" + name.center(duration - 2) + "}"

            # last course padding after
            if j == len(day) - 1:
                print_buffer[i] += " " * (
                    (beginning_minutes + total_minutes - course.time.end) // 10
                )

        print_buffer[i] += "│"

    # add current position, overriding whatever there was in the buffer
    now = datetime.now()

    weekday = now.weekday()
    offset = (now.hour * 60 + now.minute - beginning_minutes) // 10 + 1

    if offset > 0 and 0 <= weekday < len(print_buffer):
        print_buffer[weekday] = (
            print_buffer[weekday][:offset] + "#" + print_buffer[weekday][offset + 1 :]
        )

    # add vertical lines
    for i in range(len(print_buffer)):
        for j in range(1, number_of_intervals):
            if print_buffer[i][(j * interval) // 10 + 1] == " ":
                print_buffer[i] = (
                    print_buffer[i][: (j * interval) // 10 + 1]
                    + "│"
                    + print_buffer[i][(j * interval) // 10 + 2 :]
                )

    # print the buffer
    for line in print_buffer:
        print(line)

    # print the very last line
    print(
        "╰─"
        + "".join(
            "─" * (number_of_intervals) + ("┴" if i != number_of_intervals - 1 else "╯")
            for i in range(number_of_intervals)
        )
    )




def list_courses(option=""):
    """Lists information about the courses."""
    courses = get_sorted_courses()

    current_day = datetime.today()
    current_weekday = current_day.weekday()

    # split to scheduled and non-scheduled
    unscheduled = [c for c in courses if c.time is None]
    courses = [c for c in courses if c not in unscheduled]

    table = []
    for i, course in enumerate(courses):
        # lambda functions to test for various options
        # a is current weekday and b is the course's weekday
        options = {
            "": lambda a, b: True,  # all of them
            "t": lambda a, b: a == b,  # today
            "tm": lambda a, b: (a + 1) % 7 == b,  # tomorrow
            "mo": lambda a, b: b == 0,
            "tu": lambda a, b: b == 1,
            "we": lambda a, b: b == 2,
            "th": lambda a, b: b == 3,
            "fr": lambda a, b: b == 4,
            "sa": lambda a, b: b == 5,
            "su": lambda a, b: b == 6,
        }

        if option not in options:
            sys.exit("Invalid option!")

        if options[option](current_weekday, course.weekday()):
            # include the name of the day before first day's course
            if courses[i - 1].time.day != courses[i].time.day:
                weekday = weekday_to_cz(courses[i].time.day).capitalize()

                # calculate the next occurrence
                date = (
                    current_day
                    + timedelta(days=(course.weekday() - current_weekday) % 7)
                ).strftime("%-d. %-m.")

                table.append([f"{weekday} / {date}"])

            # for possibly surrounding the name with chars if it's ongoing
            name_surround_char = "•" if course.is_ongoing() else ""

            # append useful information
            table.append(
                [
                    f"{name_surround_char}{course.name if not short else course.abbreviation}{name_surround_char}",
                    "-" if course.type is None else course.type[0],
                    f"{minutes_to_HHMM(courses[i].time.start)} - {minutes_to_HHMM(courses[i].time.end)}"
                    + ("" if course.time.weeks is None else f" ({course.time.weeks})"),
                    "-" if course.classroom is None else course.classroom.number,
                ]
            )

    # list unscheduled courses only when no options are specified
    if option == "" and len(unscheduled) != 0:
        table.append(["Nerozvrženo"])
        for course in unscheduled:
            table.append(
                [
                    course.name if not short else course.abbreviation,
                    course.type[0],
                    "-",
                    "-",
                ]
            )

    # if no courses were added since the days didn't match, exit with a message
    if len(table) == 0:
        sys.exit("No courses matching the criteria found!")

    print_table(table)


def print_table(table: List[List[str]]):
    # find max width of each of the columns of the table
    column_widths = [0] * max(len(row) for row in table)
    for row in table:
        # skip weekday rows
        if len(row) != 1:
            for i, entry in enumerate(row):
                if column_widths[i] < len(entry):
                    column_widths[i] = len(entry)

    for i, row in enumerate(table):
        print(end="╭─" if i == 0 else "│ ")

        column_sep = " │ "
        max_row_width = sum(column_widths) + len(column_sep) * (len(column_widths) - 1)

        # if only one item is in the row, it's the weekday and is printed specially
        if len(row) == 1:
            print(
                (f"{' ' * max_row_width} │\n├─" if i != 0 else "")
                + f"◀ {row[0]} ▶".center(max_row_width, "─")
                + ("─╮" if i == 0 else "─┤")
            )
        else:
            for j, entry in enumerate(row):
                print(
                    entry.ljust(column_widths[j])
                    + (column_sep if j != (len(row) - 1) else " │\n"),
                    end="",
                )

    print(f"╰{'─' * (max_row_width + 2)}╯")


def check_all_websites():
    """Update caches of all course websites."""
    print("Updating course website caches:")

    for course in get_sorted_courses():
        if course.website is not None:
            print(f"- updating {course.name} ({course.type})...")
            course.update_website_cache()
        else:
            print(f"- skipping {course.name} ({course.type}) -- no website")


def browse_course(argument: Union[str, None] = None):
    "Run 'fzf' on the course folder, returning the match."
    # if none are specified, list all files of all folders
    # needs to be explicit
    if argument is None:
        courses = get_sorted_courses()
    else:
        courses = get_course_from_argument(argument)

    if len(courses) == 0:
        sys.exit("No course matching the criteria.")
    else:
        course_paths = [os.path.abspath(c.path()) for c in courses]

        # move to the most common prefix of the courses
        os.chdir(os.path.commonprefix(course_paths))

        # get whatever the user selected using fzf
        result = (
            Popen(["find . | fzf"], stdin=PIPE, stdout=PIPE, shell=True,)
            .communicate()[0]
            .decode("utf-8")
        )

        if result != "":
            print(os.path.abspath(result).strip())


def send_mail(file_name: str):
    """Send an email to the email associated with the course."""
    course = Course.from_path(os.path.dirname(os.path.join(cwd, file_name)))

    if course is None:
        sys.exit("Current working directory is not in a course directory.")

    if course.teacher is None:
        sys.exit("The course has no teacher to send the email to.")

    if course.teacher.email is None:
        sys.exit("The course has no email address.")

    import smtplib, ssl
    from email.mime.multipart import MIMEMultipart
    from email.mime.application import MIMEApplication
    from email.mime.text import MIMEText

    print("Reading the configuration file...")
    configuration = {}
    latest_attribute = None

    config_path = os.path.join(cwd, file_name)

    for i, line in enumerate(open(config_path)):
        # tabs are multi-line attributes
        if line.startswith("\t"):
            if latest_attribute is None:
                sys.exit(f"Expected attribute before tab:\n{i}: {line}")
            configuration[latest_attribute] += line.strip() + "\n"
            continue

        # skip empty lines
        if len(line.strip()) == 0:
            continue

        if ":" not in line:
            sys.exit(f"Malformed line (missing ':'):\n{i}: {line}")

        attribute, value = (
            line[: line.find(":")].strip().lower(),
            line[line.find(":") + 1 :].strip(),
        )

        configuration[attribute] = value
        latest_attribute = attribute

    print("Composing the message...")
    message = MIMEMultipart()
    message["From"] = smtp_from
    message["To"] = course.teacher.email

    for required in {"subject", "body", "attachments"}:
        if required not in configuration:
            sys.exit(f"{required.capitalize()} not read!")

    message["Subject"] = configuration["subject"]
    message.attach(MIMEText(configuration["body"]))

    for attachment in map(lambda x: x.strip(), configuration["attachments"].split()):
        extension = attachment.split(".")[-1]
        attachment_path = os.path.join(os.path.dirname(config_path), attachment)

        if not os.path.exists(attachment_path):
            sys.exit(f"Attachment '{attachment}' missing!")

        att = MIMEApplication(open(attachment_path, "rb").read())
        att.add_header("content-disposition", "attachment", filename=attachment)
        message.attach(att)

    print(f"Sending mail to '{course.teacher.email}'.")
    while (answer := input("Yes/no: ")) :
        if answer == "yes":
            break
        else:
            sys.exit("Aborting.")

    print("Connecting to the SMPT server...")
    try:
        smtp_server = smtplib.SMTP_SSL(smtp_address, smtp_port)
        smtp_server.login(smtp_login, smtp_password)
        smtp_server.send_message(message)
    except Exception as e:
        exit(f"Something went wrong when connecting to the SMTP server: {e}")

    smtp_server.close()


def open_course(kind: str, argument: Union[str, None] = None):
    """Open the course's something."""
    # if no argument is specified, default to getting the current or the next course
    courses = get_course_from_argument(argument)

    # if none were found
    if len(courses) == 0:
        sys.exit(f"No course matching the criteria.")

    # if one was found
    elif len(courses) == 1:
        course = courses[0]

        if kind == "website":
            if course.website is not None:
                open_in_firefox(course.website)
            else:
                sys.exit("The course has no website.")

        elif kind == "folder":
            open_in_ranger(course.path())

        elif kind == "notes":
            path = os.path.join(course.path(), "notes.xopp")

            # check if the default notes exist
            if not os.path.isfile(path):
                sys.exit(f"The course has no notes.")
            else:
                open_in_xournalpp(path)

    # if multiple were found
    else:
        # if multiple courses were found and they're all the same
        if kind == "folder" and all(
            [
                courses[i].abbreviation == courses[i + 1].abbreviation
                for i in range(len(courses) - 1)
            ]
        ):
            open_in_ranger(courses[0].path(ignore_type=True))

        # if multiple courses were found and the websites match
        elif kind == "website" and all(
            [
                courses[i].website == courses[i + 1].website
                for i in range(len(courses) - 1)
            ]
        ):
            open_in_firefox(courses[0].website)
        else:
            sys.exit(f"Multiple courses matching the identifier.")


def compile_cron_jobs():
    """Adds notifications for upcoming classes to the crontab file."""
    # check if the script is running as root; if not, call itself as root
    if not os.geteuid() == 0:
        call(["sudo", "python3", *sys.argv])
        sys.exit()

    courses = get_sorted_courses(include_unscheduled=False)

    cron_file = "/etc/crontab"
    user = os.getlogin()

    # comments to encapsulate the generated cron jobs
    cron_file_comments = {
        "beginning": "# BEGINNING: course schedule crons (autogenerated, do not change)",
        "end": "# END: course schedule crons",
    }

    with open(cron_file, "r+") as f:
        contents = f.readlines()
        f.seek(0)

        # write to file till we reach the end or the comment section is skipped, so we
        # can add the new course-related cron jobs
        i = 0
        while i < len(contents):
            if contents[i].strip() == cron_file_comments["beginning"]:
                while contents[i].strip() != cron_file_comments["end"]:
                    i += 1

                i += 1
                break
            else:
                f.write(contents[i])

            i += 1

        f.write(cron_file_comments["beginning"] + "\n")

        for j, course in enumerate(courses):
            # the messages regarding the course
            messages = [
                (
                    get_cron_schedule(course.time.end - 5, course.weekday()),
                    get_next_course_message(j, courses),
                ),
                (
                    get_cron_schedule(course.time.start, course.weekday()),
                    f"právě začal předmět <i>{course.name} ({course.type})</i>.",
                ),
            ]

            for cron_schedule, body in messages:
                f.write(f"{cron_schedule} {user} dunstify rozvrh '{body}'\n")

        f.write(cron_file_comments["end"] + "\n")

        # write the rest of the file
        while i < len(contents):
            f.write(contents[i])
            i += 1

        # cut whatever is left
        f.truncate()

        print(f"Course messages generated and saved to {cron_file}.")


def list_help(tree: Dict, indentation: int):
    """Recursively pretty-prints a nested dictionary (with lists being functions)."""
    for k, v in tree.items():
        decision = "  " * indentation + f"{{{', '.join(k)}}}"

        # either it's a function with annotation
        if type(v) is not dict:
            print(decision.ljust(help_offset) + v[1])

        # or it's simply a decision
        else:
            print(decision)
            list_help(v, indentation + 1)


decision_tree = {
    ("list",): {
        ("courses",): (list_courses, "List information about the courses."),
        ("finals",): (list_finals, "List dates of all finals."),
        ("timeline",): (list_timeline, "List the courses in a timeline."),
    },
    ("cron",): (compile_cron_jobs, "Add crontab notifications for all courses.",),
    ("browse",): (
        browse_course,
        "Run 'fzf' on the course folder, returning the match.",
    ),
    ("send",): (send_mail, "Send an email to the email of the course."),
    ("open",): {
        ("course",): (
            partial(open_course, "folder"),
            "Open the course's folder in Ranger.",
        ),
        ("website",): (
            partial(open_course, "website"),
            "Open the course's website in FireFox.",
        ),
        ("notes",): (
            partial(open_course, "notes"),
            "Open the course's notes in Xournal++.",
        ),
    },
}

arguments = sys.argv[1:]

# parse flags
i = 0
while i < len(arguments):
    if not arguments[i].startswith("-"):
        i += 1
        continue

    # TODO: use reflection to do this automatically?
    argument = arguments.pop(i)
    if argument in ("--short", "-s"):
        short = True

    i += 1


# if no arguments are specified, list help
if len(arguments) == 0:
    print(
        "A multi-purpose script for simplifying my MFF UK education.\n"
        + "\n"
        + "supported options:"
    )

    list_help(decision_tree, 1)

    print(
        "\nsupported flags:\n"
        + "  --short/-s".ljust(help_offset)
        + "Shorten output (when possible)."
    )

    sys.exit()

# go down the decision tree
parsed_arguments = []
while len(arguments) != 0 and type(decision_tree) is dict:
    argument = arguments.pop(0)

    # sort the decisions by their common prefix with the argument
    decisions = sorted(
        (max([len(argument) if s.startswith(argument) else 0 for s in d]), d)
        for d in decision_tree
    )

    # if no match is found, quit with error
    if decisions[-1][0] == 0:
        sys.exit(
            f"ERROR: '{argument}' doesn't match decisions in the decision tree: {{{', '.join(' or '.join(d) for d in decision_tree)}}}"
        )

    # filter out the sub-optimal decisions
    decisions = list(filter(lambda x: x[0] == decisions[-1][0], decisions))

    # if there are multiple optimal solutions, the command is ambiguous
    if len(decisions) > 1:
        sys.exit(
            f"ERROR: Ambiguous decisions for '{argument}': {{{', '.join(' or '.join(d) for _, d in decisions)}}}",
        )
    else:
        parsed_arguments.append(decisions[0][1])
        decision_tree = decision_tree[decisions[0][1]]

# if the decision tree isn't a function by now, exit; else extract the function
if type(decision_tree) is dict:
    sys.exit(
        f"ERROR: Decisions remaining: {{{', '.join(' or '.join(d) for d in decision_tree)}}}"
    )

try:
    decision_tree[0](*arguments)
except TypeError:
    print(
        f"Invalid arguments for '{', '.join([' '.join(a) for a in parsed_arguments])}'."
    )
